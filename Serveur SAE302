import sys
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
import socket
import mysql.connector
import datetime
from enum import Enum


class AuthenticationWindow(QDialog):
    def __init__(self):
        super().__init__()

        self.layout = QVBoxLayout()

        self.username_label = QLabel("Identifiant:")
        self.layout.addWidget(self.username_label)

        self.username_input = QLineEdit()
        self.layout.addWidget(self.username_input)

        self.password_label = QLabel("Mot de passe:")
        self.layout.addWidget(self.password_label)

        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.layout.addWidget(self.password_input)

        self.error_label = QLabel()
        self.error_label.setStyleSheet("color: red")
        self.layout.addWidget(self.error_label)

        self.login_button = QPushButton("Se connecter", self)
        self.login_button.clicked.connect(self.authenticate)
        self.layout.addWidget(self.login_button)

        self.setLayout(self.layout)

    def authenticate(self):
        username = self.username_input.text()
        password = self.password_input.text()

        if username == "root" and password == "root":
            self.accept()
        else:
            self.error_label.setText("Identifiant ou mot de passe incorrect.")


class ClientHandler(QThread):
    disconnected = pyqtSignal(tuple)

    def __init__(self, client_socket, addr, server, username):
        super().__init__()
        self.client_socket = client_socket
        self.addr = addr
        self.server = server
        self.username = username
        self.current_channel = None  # Ajout de la variable pour suivre le canal actuel

    def run(self):
        try:
            while True:
                data = self.client_socket.recv(1024)
                if not data:
                    break
                decoded_data = data.decode('utf-8')
                if decoded_data.lower() == "bye":
                    break

                # Utilisez directement la méthode du serveur
                self.server.handle_client_message(decoded_data, self.username, self)

        except Exception as e:
            print(f"Erreur de réception : {e}")
        finally:
            self.client_socket.close()
            self.disconnected.emit(self.addr)

    def set_current_channel(self, channel_id):
        self.current_channel = channel_id

    def send_message(self, message):
        try:
            self.client_socket.sendall(message.encode('utf-8'))
        except Exception as e:
            print(f"Erreur lors de l'envoi du message au client {self.addr}: {e}")

    def handle_client_message(self, message):
        sender_username, content = self.extract_username_and_content(message)

        if self.is_user_banned(sender_username):
            self.server.message_received.emit(f"{sender_username} est banni et ne peut pas envoyer de messages.")
            return

        # Enregistrement du message uniquement si ce n'est pas un changement de canal
        if not content.lower().startswith("changement de canal"):
            current_channel_id = self.current_channel
            if current_channel_id is not None:
                content = content.strip()
                self.server.message_received.emit(f"{sender_username}: {content}")
                self.server.insert_message(sender_username, current_channel_id, content)
                self.server.broadcast_message(f"{sender_username}: {content}", self.addr)
        else:
            # Si c'est un "Changement de canal", mettez à jour le canal actuel du client
            parts = content.split(":")
            if len(parts) >= 2:
                channel_name = parts[1].strip()
                channel_id = self.server.CHANNEL_IDS.get(channel_name)
                if channel_id is not None:
                    # Mettez à jour le canal actuel du client
                    self.set_current_channel(channel_id)
                    self.server.message_received.emit(f"{sender_username}: Changement de canal : {channel_name}")
                    self.server.insert_message(sender_username, None, f"Changement de canal : {channel_name}")
                    self.server.broadcast_message(f"{sender_username}: Changement de canal : {channel_name}", self.addr)
                else:
                    self.server.message_received.emit(f"Canal non trouvé : {channel_name}")
            else:
                self.server.message_received.emit(f"Commande de changement de canal mal formée : {content}")

    def extract_username_and_content(self, message):
        # Divisez le message en parties en utilisant le délimiteur ":"
        parts = message.split(':')

        # Assurez-vous qu'il y a au moins deux parties (username et le reste du message)
        if len(parts) >= 2:
            sender_username = parts[0].strip()
            content = ':'.join(parts[1:]).strip()
            return sender_username, content

        return "", ""


    def is_user_banned(self, username):
        try:
            cursor = self.server.db_connection.cursor()
            cursor.execute("SELECT ban_expire FROM users WHERE username = %s", (username,))
            ban_expire = cursor.fetchone()[0]
            cursor.close()
            return ban_expire is not None and ban_expire > datetime.datetime.now()

        except Exception as e:
            print(f"Erreur lors de la vérification du statut de ban pour {username} : {e}")
            return False

class ChannelStatus(Enum):
    OPEN = "Ouvert"
    ON_REQUEST = "Sur demande"
    VALIDATION_REQUIRED = "Validation nécessaire"

class Server(QThread):
    client_connected = pyqtSignal(tuple)
    message_received = pyqtSignal(str)
    new_user_created = pyqtSignal(str)
    channel_request_received = pyqtSignal(str, str)

    CHANNEL_IDS = {
        "Général": 1,
        "Blabla": 2,
        "Comptabilité": 3,
        "Informatique": 4,
        "Marketing": 5
    }

    def __init__(self):
        super().__init__()

        self.auth_window = AuthenticationWindow()
        if self.auth_window.exec() != QDialog.Accepted:
            sys.exit(0)

        self.db_connection = mysql.connector.connect(
            host="localhost",
            user="root",
            password="toto",
            database="SAE302"
        )
        print("BDD bien connecté")
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.bind(('0.0.0.0', 5555))
        self.server_socket.listen()
        self.clients = []
        self.window = ServerWindow(self)
        self.window.stop_server_signal.connect(self.stop_server)
        self.window.show()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.check_user_timeouts)
        self.timer.start(60000)  # Vérifier toutes les 60 secondes (ajustez selon vos besoins)
        self.channels_requests = {}  # Dictionnaire pour stocker les demandes de canaux en attente d'approbation

    def run(self):
        try:
            while True:
                client_socket, addr = self.server_socket.accept()
                self.client_connected.emit(addr)
                self.message_received.emit(f"Connexion acceptée de {addr[0]}:{addr[1]}")

                verified_username = self.verify_credentials(client_socket)
                if verified_username:
                    client_handler = ClientHandler(client_socket, addr, self, verified_username)
                    client_handler.set_current_channel(1)  # Spécifie le canal initial ici
                    client_handler.disconnected.connect(self.handle_client_disconnected)
                    client_handler.start()

                    self.clients.append((client_handler, addr))

                else:
                    print(f"Identification échouée. Connexion refusée pour {addr[0]}:{addr[1]}")
                    self.window.text_edit.append(f"Identification échouée. Connexion refusée pour {addr[0]}:{addr[1]}")

        except Exception as e:
            print(f"Erreur de connexion : {e}")

    def authenticate(self, client_socket):
        try:
            data = client_socket.recv(1024)
            if not data:
                return False

            credentials = data.decode('utf-8').split(':')
            action = credentials[0]

            if action == "création_utilisateur":
                return self.handle_user_creation(client_socket, credentials)
            elif action == "connexion":
                # Modifiez ici pour passer le nom d'utilisateur à la création de ClientHandler
                return self.handle_user_authentication(client_socket, credentials)
            else:
                print(f"Action non reconnue : {action}")
                return False

        except Exception as e:
            print(f"Erreur lors de l'authentification : {e}")
            return False

    def handle_user_creation(self, client_socket, credentials):
        try:
            # Création d'un nouvel utilisateur
            username, pseudo, password = credentials[1], credentials[2], credentials[3]

            # Insérer le nouvel utilisateur dans la base de données
            if self.insert_new_user(username, pseudo, password):
                # Informer que le nouvel utilisateur a été créé
                self.new_user_created.emit(f"Nouvel utilisateur créé: {username}")
                return True
            else:
                print(f"Erreur lors de la création du nouvel utilisateur : {username}")
                return False

        except Exception as e:
            print(f"Erreur lors de la gestion de la création d'utilisateur : {e}")
            return False

    def handle_user_authentication(self, client_socket, credentials):
        try:
            # Vérification des identifiants pour la connexion
            username, password = credentials[1], credentials[2]

            cursor = self.db_connection.cursor()
            cursor.execute("SELECT * FROM users WHERE username = %s AND password = %s AND ban = 0",
                           (username, password))
            result = cursor.fetchone()
            cursor.close()

            if result:
                print(f"Identifiants valides pour {username}")

                # Imprimez le nom d'utilisateur ici pour vous assurer qu'il est correct
                print(f"Nom d'utilisateur transmis à la création de ClientHandler : {username}")

                # Créez une instance de ClientHandler en passant le nom d'utilisateur
                client_handler = ClientHandler(client_socket, None, self, username)
                client_handler.set_current_channel(1)  # Spécifie le canal initial ici
                client_handler.disconnected.connect(self.handle_client_disconnected)
                client_handler.start()
                self.clients.append((client_handler, None))
            else:
                print(f"Identifiants invalides pour {username}")

            return result is not None

        except Exception as e:
            print(f"Erreur lors de la vérification des identifiants : {e}")
            return False

    def stop_server(self):
        self.window.set_status("Le serveur est arrêté.")
        self.window.text_edit.append("Le serveur a été arrêté.")
        self.server_socket.close()

        for client_handler, _ in self.clients:
            client_handler.client_socket.close()

        self.wait()

    def verify_credentials(self, client_socket):
        try:
            data = client_socket.recv(1024)
            if not data:
                return False

            credentials = data.decode('utf-8').split(':')
            if credentials[0] == "création_utilisateur":
                # Création d'un nouvel utilisateur
                username, pseudo, password = credentials[1], credentials[2], credentials[3]

                # Insérer le nouvel utilisateur dans la base de données
                if self.insert_new_user(username, pseudo, password):
                    # Informer que le nouvel utilisateur a été créé
                    self.new_user_created.emit(f"Nouvel utilisateur créé: {username}")
                    return True
                else:
                    print(f"Erreur lors de la création du nouvel utilisateur : {username}")
                    return False
            else:
                # Vérification des identifiants pour la connexion
                username, password = credentials[0], credentials[1]

                cursor = self.db_connection.cursor()
                cursor.execute("SELECT * FROM users WHERE username = %s AND password = %s AND ban = 0",
                               (username, password))
                result = cursor.fetchone()
                cursor.close()

                if result:
                    print(f"Identifiants valides pour {username}")
                    print(f"Nom d'utilisateur transmis à la création de ClientHandler : {username}")
                    return username
                else:
                    print(f"Identifiants invalides ou utilisateur banni pour {username}")
                    return None
                return result is not None

        except Exception as e:
            print(f"Erreur lors de la vérification des identifiants : {e}")
            return False

    def insert_new_user(self, username, pseudo, password):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("INSERT INTO users (username, pseudo, password) VALUES (%s, %s, %s)",
                           (username, pseudo, password))
            self.db_connection.commit()
            cursor.close()
            return True
        except Exception as e:
            print(f"Erreur lors de l'insertion du nouvel utilisateur dans la base de données : {e}")
            return False

    def handle_client_message(self, message, username, client_handler):
        sender_username, content = message.split(':', 1)
        sender_username = sender_username.strip()

        if "Demande de canal" in content:
            self.handle_channel_request(client_handler, sender_username, content)
            return

        # Enregistrement du message uniquement si ce n'est pas un changement de canal
        if not message.lower().startswith("changement de canal"):
            current_channel_id = client_handler.current_channel
            if current_channel_id is not None:
                content = content.strip()
                self.message_received.emit(f"{sender_username}: {content}")
                self.insert_message(sender_username, current_channel_id, content)
                self.broadcast_message(f"{sender_username}: {content}", client_handler.addr)
        else:
            # Si c'est un "Changement de canal", mettez à jour le canal actuel du client
            parts = message.split(":")
            if len(parts) >= 2:
                channel_name = parts[1].strip()
                channel_id = self.CHANNEL_IDS.get(channel_name)
                if channel_id is not None:
                    client_handler.set_current_channel(channel_id)
                    self.message_received.emit(f"{sender_username}: {message}")
                    self.insert_message(sender_username, None, message)
                    self.broadcast_message(f"{sender_username}: {message}", client_handler.addr)
                else:
                    self.message_received.emit(f"Canal non trouvé : {channel_name}")
            else:
                self.message_received.emit(f"Commande de changement de canal mal formée : {message}")

    def insert_message(self, username, channel_id, content):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("INSERT INTO messages (username, channel_id, content) VALUES (%s, %s, %s)",
                           (username, channel_id, content))
            self.db_connection.commit()
            cursor.close()
        except Exception as e:
            print(f"Erreur lors de l'insertion du message dans la base de données : {e}")

    def broadcast_message(self, message, sender_addr):
        # Exclure les messages "Changement de canal"
        if "Changement de canal" not in message:
            for client_handler, addr in self.clients:
                if addr != sender_addr:
                    try:
                        client_handler.client_socket.sendall(message.encode('utf-8'))
                    except Exception as e:
                        print(f"Erreur lors de l'envoi du message au client {addr}: {e}")

    def handle_client_disconnected(self, addr):
        for client_handler, client_addr in self.clients:
            if client_addr == addr:
                self.clients.remove((client_handler, client_addr))
                self.message_received.emit(f"Client déconnecté : {addr[0]}:{addr[1]}")
                self.window.text_edit.append(f"Client déconnecté : {addr[0]}:{addr[1]}")

    def kick_user(self, username, kick_expire):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET kick_expire = %s, ban = 1 WHERE username = %s", (kick_expire, username))
            self.db_connection.commit()
            cursor.close()
            self.broadcast_message(f"{username} a été kické jusqu'au {kick_expire}.", None)
        except Exception as e:
            print(f"Erreur lors du Kick de l'utilisateur {username} : {e}")

    def ban_user(self, username, ban_expire):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET ban_expire = %s, ban = 1 WHERE username = %s", (ban_expire, username))
            self.db_connection.commit()
            cursor.close()
            self.broadcast_message(f"{username} a été banni jusqu'au {ban_expire}.", None)
        except Exception as e:
            print(f"Erreur lors du Ban de l'utilisateur {username} : {e}")

    def unban_user(self, username):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET ban_expire = NULL, ban = 0 WHERE username = %s", (username,))
            self.db_connection.commit()
            cursor.close()
            self.broadcast_message(f"{username} n'est plus banni.", None)
        except Exception as e:
            print(f"Erreur lors de la suppression du Ban de l'utilisateur {username} : {e}")

    def unkick_user(self, username):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET kick_expire = NULL, ban = 0 WHERE username = %s", (username,))
            self.db_connection.commit()
            cursor.close()
            self.broadcast_message(f"{username} n'est plus kické.", None)
        except Exception as e:
            print(f"Erreur lors de la suppression du Kick de l'utilisateur {username} : {e}")

    def check_user_timeouts(self):
        try:
            cursor = self.db_connection.cursor(dictionary=True)
            cursor.execute("SELECT username, kick_expire, ban_expire FROM users WHERE kick_expire IS NOT NULL OR ban_expire IS NOT NULL")
            users = cursor.fetchall()
            cursor.close()

            current_datetime = datetime.datetime.now()

            for user in users:
                username = user["username"]
                kick_expire = user["kick_expire"]
                ban_expire = user["ban_expire"]

                if kick_expire is not None and kick_expire < current_datetime:
                    # Réinitialiser la colonne kick_expire à zéro
                    self.reset_kick_expire(username)

                if ban_expire is not None and ban_expire < current_datetime:
                    # Réinitialiser les colonnes ban_expire à zéro
                    self.reset_ban_expire(username)

        except Exception as e:
            print(f"Erreur lors de la vérification des délais d'expiration : {e}")

    def reset_kick_expire(self, username):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET kick_expire = NULL, ban = 0 WHERE username = %s", (username,))
            self.db_connection.commit()
            cursor.close()
        except Exception as e:
            print(f"Erreur lors de la suppression du Kick de l'utilisateur {username} : {e}")

    def reset_ban_expire(self, username):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET ban_expire = NULL, ban = 0 WHERE username = %s", (username,))
            self.db_connection.commit()
            cursor.close()
        except Exception as e:
            print(f"Erreur lors de la suppression du Ban de l'utilisateur {username} : {e}")

    def handle_channel_request(self, client_handler, sender_username, request_message):
        parts = request_message.split(":")
        if len(parts) >= 2:
            channel_name = parts[1].strip()
            channel_id = self.CHANNEL_IDS.get(channel_name)
            if channel_id is not None:
                if self.is_user_in_channel(sender_username, channel_id):
                    self.message_received.emit(f"Membre du salon {channel_id} : {sender_username}")
                else:
                    if self.is_channel_request_valid(channel_id, client_handler):
                        # Émettre le signal pour demander l'affichage de la fenêtre pop-up
                        self.channel_request_received.emit(
                            sender_username, channel_name)
                    else:
                        if channel_id not in self.channels_requests:
                            self.channels_requests[channel_id] = set()

                        self.channels_requests[channel_id].add(sender_username)
                        self.message_received.emit(
                            f"Demande de salon en attente d'approbation pour {sender_username} : {channel_name}")
            else:
                self.message_received.emit(f"Canal non trouvé : {channel_name}")
        else:
            self.message_received.emit(
                f"Commande de demande de salon mal formée : {request_message}")

    def add_user_to_channel(self, username, channel_id):
        try:
            # Vérifier si l'utilisateur est déjà dans le canal
            if not self.is_user_in_channel(username, channel_id):
                # Si l'utilisateur n'est pas dans le canal, ajouter à la table
                cursor = self.db_connection.cursor()
                cursor.execute("INSERT INTO user_channels (username, channel_id) VALUES (%s, %s)",
                               (username, channel_id))
                self.db_connection.commit()
                cursor.close()

        except Exception as e:
            print(f"Erreur lors de l'ajout de l'utilisateur au canal dans la base de données : {e}")

    def is_user_in_channel(self, username, channel_id):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT COUNT(*) FROM user_channels WHERE username = %s AND channel_id = %s",
                           (username, channel_id))
            result = cursor.fetchone()[0]
            cursor.close()

            # Si le résultat est supérieur à zéro, l'utilisateur est déjà dans le canal
            return result > 0

        except Exception as e:
            print(f"Erreur lors de la vérification de l'association de l'utilisateur au canal : {e}")
            return False
    def insert_user_channel(self, username, channel_id):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("INSERT INTO user_channels (username, channel_id) VALUES (%s, %s)", (username, channel_id))
            self.db_connection.commit()
            cursor.close()
        except Exception as e:
            print(f"Erreur lors de l'insertion de l'adhésion dans la base de données : {e}")

    def broadcast_channel_members(self, channel_id):
        try:
            cursor = self.db_connection.cursor(dictionary=True)
            cursor.execute("SELECT username FROM user_channels WHERE channel_id = %s", (channel_id,))
            members = cursor.fetchall()
            cursor.close()

            member_names = [member["username"] for member in members]
            member_list = ", ".join(member_names)

            self.message_received.emit(f"Membres du salon {channel_id} : {member_list}")

        except Exception as e:
            print(f"Erreur lors de la diffusion des membres du salon : {e}")

    def is_channel_request_valid(self, channel_id, client_handler):
        # Ajoutez ici votre logique pour valider la demande de salon
        # Par exemple, vérifiez si le salon nécessite une validation

        # Supposez que les canaux "Blabla", "Informatique" et "Marketing" nécessitent une validation
        channels_requiring_approval = {"Comptabilité", "Informatique", "Marketing"}

        # Vérifiez si le canal nécessite une validation
        if channel_id in self.CHANNEL_IDS.values() and self.get_channel_name(channel_id) in channels_requiring_approval:
            # Le canal nécessite une validation, vous devrez implémenter votre propre logique ici
            # Par exemple, vous pouvez vérifier une liste d'approbation ou d'autres critères
            return self.is_approval_required_for_user(channel_id, client_handler.username)
        else:
            # Le canal ne nécessite pas de validation
            return True

    def is_approval_required_for_user(self, channel_id, username):
        try:
            # Exécutez une requête pour vérifier si l'utilisateur est approuvé pour le canal
            cursor = self.db_connection.cursor()
            cursor.execute("SELECT COUNT(*) FROM user_channels WHERE username = %s AND channel_id = %s",
                           (username, channel_id))
            result = cursor.fetchone()[0]
            cursor.close()

            # Si l'utilisateur est dans la table user_channels, cela signifie qu'il est approuvé
            # Sinon, l'approbation est nécessaire
            return result == 0

        except Exception as e:
            print(f"Erreur lors de la vérification de l'approbation de l'utilisateur : {e}")
            return False

    def get_channel_name(self, channel_id):
        # Retourne le nom du canal à partir de son identifiant
        for name, cid in self.CHANNEL_IDS.items():
            if cid == channel_id:
                return name
        return None

    def validate_channel_request(self, username, channel_id, approve):
        if channel_id in self.channels_requests and username in self.channels_requests[channel_id]:
            self.channels_requests[channel_id].remove(username)
            if approve:
                # Ajoutez l'utilisateur au salon et insérez l'adhésion dans la base de données
                self.insert_user_channel(username, channel_id)
                self.message_received.emit(f"Demande d'adhésion approuvée : {username} rejoint le salon {channel_id}.")
            else:
                self.message_received.emit(f"Demande d'adhésion refusée : {username} pour le salon {channel_id}.")

    def is_user_waiting_for_approval(self, channel_id, username):
        # Vérifie si l'utilisateur est en attente d'approbation pour un canal spécifique
        return channel_id in self.channels_requests and username in self.channels_requests[channel_id]

    def remove_user_from_approval_list(self, channel_id, username):
        # Retire l'utilisateur de la liste des demandes en attente
        if channel_id in self.channels_requests and username in self.channels_requests[channel_id]:
            self.channels_requests[channel_id].remove(username)

class ChannelRequestDialog(QDialog):
    def __init__(self, sender_username, channel_name, accept_callback, parent=None):
        super().__init__(parent)

        self.setWindowTitle("Demande de Salon")
        self.setGeometry(300, 300, 300, 150)

        layout = QVBoxLayout()

        label = QLabel(f"{sender_username} a demandé à rejoindre le salon {channel_name}.")
        layout.addWidget(label)

        accept_button = QPushButton("Accepter", self)
        accept_button.clicked.connect(lambda: self.accept_and_close(accept_callback, sender_username, channel_name))
        layout.addWidget(accept_button)

        refuse_button = QPushButton("Refuser", self)
        refuse_button.clicked.connect(self.reject)
        layout.addWidget(refuse_button)

        self.setLayout(layout)

    def accept_and_close(self, accept_callback, sender_username, channel_name):
        accept_callback(sender_username, channel_name)
        self.accept()  # Ferme la boîte de dialogue

class ServerWindow(QMainWindow):
    stop_server_signal = pyqtSignal()

    def __init__(self, server):
        super().__init__()

        self.server = server

        self.setWindowTitle("Serveur")
        self.setGeometry(100, 100, 600, 400)

        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)

        self.layout = QVBoxLayout()

        self.text_edit = QTextEdit(self)
        self.layout.addWidget(self.text_edit)

        self.input_line = QLineEdit(self)
        self.layout.addWidget(self.input_line)

        self.send_button = QPushButton("Envoyer", self)
        self.send_button.clicked.connect(self.send_message)
        self.layout.addWidget(self.send_button)

        self.stop_button = QPushButton("Arrêter le serveur", self)
        self.stop_button.clicked.connect(self.stop_server)
        self.layout.addWidget(self.stop_button)

        self.central_widget.setLayout(self.layout)

        self.setup_ui()

        self.server.message_received.connect(self.handle_message_received)
        self.server.client_connected.connect(self.handle_client_connected)
        self.server.new_user_created.connect(self.handle_new_user_created)

        self.kick_button = QPushButton("Kick", self)
        self.kick_button.clicked.connect(self.kick_user)
        self.layout.addWidget(self.kick_button)

        self.ban_button = QPushButton("Ban", self)
        self.ban_button.clicked.connect(self.ban_user)
        self.layout.addWidget(self.ban_button)

        self.unban_button = QPushButton("Supprimer le Ban", self)
        self.unban_button.clicked.connect(self.unban_user)
        self.layout.addWidget(self.unban_button)

        self.unkick_button = QPushButton("Enlever le Kick", self)
        self.unkick_button.clicked.connect(self.unkick_user)
        self.layout.addWidget(self.unkick_button)

        self.kick_button = QPushButton("Pour Kick", self)
        self.layout.addWidget(self.kick_button)

        self.kick_datetime_edit = QDateTimeEdit(self)
        self.layout.addWidget(self.kick_datetime_edit)

        self.ban_button = QPushButton("Pour Ban", self)
        self.layout.addWidget(self.ban_button)

        self.ban_datetime_edit = QDateTimeEdit(self)
        self.layout.addWidget(self.ban_datetime_edit)

        server.channel_request_received.connect(self.show_channel_request_dialog)

        self.server.start()

    def stop_server(self):
        self.stop_server_signal.emit()

    def send_message(self):
        self.server.broadcast_message(f"Server: {self.input_line.text()}", None)
        self.input_line.clear()

    def handle_message_received(self, message):
        self.text_edit.append(message)

    def handle_client_connected(self, addr):
        self.text_edit.append(f"Client connecté : {addr[0]}:{addr[1]}")

    def handle_new_user_created(self, message):
        print("Handling new user creation:", message)
        self.text_edit.append(message)
        # Ajoutez ici le code pour traiter la création d'un nouvel utilisateur, si nécessaire

    def kick_user(self):
        username = self.get_selected_username()
        if username:
            # Utilisez la valeur sélectionnée dans le QDateTimeEdit
            kick_expire = self.kick_datetime_edit.dateTime().toPyDateTime()
            self.server.kick_user(username, kick_expire)

    def ban_user(self):
        username = self.get_selected_username()
        if username:
            ban_expire = self.ban_datetime_edit.dateTime().toPyDateTime()
            self.server.ban_user(username, ban_expire)

    def unban_user(self):
        username = self.get_selected_username()
        if username:
            self.server.unban_user(username)

    def unkick_user(self):
        username = self.get_selected_username()
        if username:
            self.server.unkick_user(username)

    def get_selected_username(self):
        index = self.user_combo.currentIndex()
        if index > 0:
            return self.user_combo.currentText()
        return None

    def setup_ui(self):

        # Créer un menu déroulant pour les utilisateurs
        self.user_combo = QComboBox(self)
        self.layout.addWidget(self.user_combo)

        # Charger les utilisateurs depuis la base de données
        self.load_users()

    def load_users(self):
        try:
            cursor = self.server.db_connection.cursor(dictionary=True)
            cursor.execute("SELECT username FROM users")
            users = cursor.fetchall()
            cursor.close()

            # Ajouter les utilisateurs au menu déroulant
            self.user_combo.addItem("Sélectionner un utilisateur")
            for user in users:
                self.user_combo.addItem(user["username"])

        except Exception as e:
            print(f"Erreur lors du chargement des utilisateurs : {e}")

    def show_channel_request_dialog(self, sender_username, channel_name):
        try:
            print("Avant la création de la fenêtre pop-up")
            dialog = ChannelRequestDialog(sender_username, channel_name, self.accept_channel_request)
            print("Après la création de la fenêtre pop-up")
            result = dialog.exec_()
        except Exception as e:
            print(f"Erreur lors de l'affichage de la fenêtre pop-up : {e}")
        finally:
            # Assurez-vous de fermer la fenêtre pop-up après utilisation
            if 'dialog' in locals():
                dialog.close()

    def accept_channel_request(self, sender_username, channel_name):
        # Ajoutez ici la logique pour accepter la demande de canal
        # Par exemple, approuver l'utilisateur et mettre à jour la base de données
        channel_id = self.server.CHANNEL_IDS.get(channel_name)

        if channel_id is not None:
            # Ajoutez l'utilisateur au canal et insérez l'adhésion dans la base de données
            self.server.add_user_to_channel(sender_username, channel_id)
            self.server.message_received.emit(
                f"Demande d'adhésion approuvée : {sender_username} rejoint le salon {channel_name}.")
            self.server.broadcast_channel_members(channel_id)
        else:
            self.server.message_received.emit(f"Canal non trouvé : {channel_name}")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    server = Server()
    window = ServerWindow(server)
    sys.exit(app.exec_())
