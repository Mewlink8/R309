import sys
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
import socket
import mysql.connector
import datetime


class AuthenticationWindow(QDialog):
    def __init__(self):
        super().__init__()

        self.layout = QVBoxLayout()

        self.username_label = QLabel("Identifiant:")
        self.layout.addWidget(self.username_label)

        self.username_input = QLineEdit()
        self.layout.addWidget(self.username_input)

        self.password_label = QLabel("Mot de passe:")
        self.layout.addWidget(self.password_label)

        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.layout.addWidget(self.password_input)

        self.error_label = QLabel()
        self.error_label.setStyleSheet("color: red")
        self.layout.addWidget(self.error_label)

        self.login_button = QPushButton("Se connecter", self)
        self.login_button.clicked.connect(self.authenticate)
        self.layout.addWidget(self.login_button)

        self.setLayout(self.layout)

    def authenticate(self):
        username = self.username_input.text()
        password = self.password_input.text()

        if username == "root" and password == "root":
            self.accept()
        else:
            self.error_label.setText("Identifiant ou mot de passe incorrect.")


class ClientHandler(QThread):
    disconnected = pyqtSignal(tuple)

    def __init__(self, client_socket, addr, server, username):
        super().__init__()
        self.client_socket = client_socket
        self.addr = addr
        self.server = server
        self.username = username
        self.current_channel = None  # Ajout de la variable pour suivre le canal actuel

    def run(self):
        try:
            while True:
                data = self.client_socket.recv(1024)
                if not data:
                    break
                decoded_data = data.decode('utf-8')
                if decoded_data.lower() == "bye":
                    break

                # Utilisez directement la méthode du serveur
                self.server.handle_client_message(decoded_data, self.username, self)

        except Exception as e:
            print(f"Erreur de réception : {e}")
        finally:
            self.client_socket.close()
            self.disconnected.emit(self.addr)

    def set_current_channel(self, channel_id):
        self.current_channel = channel_id

    def send_message(self, message):
        try:
            self.client_socket.sendall(message.encode('utf-8'))
        except Exception as e:
            print(f"Erreur lors de l'envoi du message au client {self.addr}: {e}")

    def handle_client_message(self, message, username, client_handler):
        sender_username, content = message.split(':', 1)
        sender_username = sender_username.strip()

        if self.is_user_banned(username):
            self.server.message_received.emit(f"{username} est banni et ne peut pas envoyer de messages.")
            return

        # Enregistrement du message uniquement si ce n'est pas un changement de canal
        if not message.lower().startswith("changement de canal"):
            current_channel_id = client_handler.current_channel
            if current_channel_id is not None:
                content = content.strip()
                self.server.message_received.emit(f"{sender_username}: {content}")
                self.server.insert_message(sender_username, current_channel_id, content)
                self.server.broadcast_message(f"{sender_username}: {content}", self.addr)
        else:
            # Si c'est un "Changement de canal", mettez à jour le canal actuel du client
            parts = message.split(":")
            if len(parts) >= 2:
                channel_name = parts[1].strip()
                channel_id = self.server.CHANNEL_IDS.get(channel_name)
                if channel_id is not None:
                    client_handler.set_current_channel(channel_id)
                    self.server.message_received.emit(f"{sender_username}: {message}")
                    self.server.insert_message(sender_username, None, message)
                    self.server.broadcast_message(f"{sender_username}: {message}", self.addr)
                else:
                    self.server.message_received.emit(f"Canal non trouvé : {channel_name}")
            else:
                self.server.message_received.emit(f"Commande de changement de canal mal formée : {message}")

    def is_user_banned(self, username):
        try:
            cursor = self.server.db_connection.cursor()
            cursor.execute("SELECT ban_expire FROM users WHERE username = %s", (username,))
            ban_expire = cursor.fetchone()[0]
            cursor.close()
            return ban_expire is not None and ban_expire > datetime.datetime.now()

        except Exception as e:
            print(f"Erreur lors de la vérification du statut de ban pour {username} : {e}")
            return False


class Server(QThread):
    client_connected = pyqtSignal(tuple)
    message_received = pyqtSignal(str)
    new_user_created = pyqtSignal(str)

    CHANNEL_IDS = {
        "Général": 1,
        "Blabla": 2,
        "Comptabilité": 3,
        "Informatique": 4,
        "Marketing": 5
    }

    def __init__(self):
        super().__init__()
        self.auth_window = AuthenticationWindow()
        if self.auth_window.exec() != QDialog.Accepted:
            sys.exit(0)

        self.db_connection = mysql.connector.connect(
            host="localhost",
            user="root",
            password="toto",
            database="SAE302"
        )
        print("BDD bien connecté")
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.bind(('0.0.0.0', 5555))
        self.server_socket.listen()
        self.clients = []
        self.window = ServerWindow(self)
        self.window.stop_server_signal.connect(self.stop_server)
        self.window.show()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.check_user_timeouts)
        self.timer.start(60000)  # Vérifier toutes les 60 secondes (ajustez selon vos besoins)

    def run(self):
        try:
            while True:
                client_socket, addr = self.server_socket.accept()
                self.client_connected.emit(addr)
                self.message_received.emit(f"Connexion acceptée de {addr[0]}:{addr[1]}")

                if self.verify_credentials(client_socket):
                    username = "root"  # Utilisez le nom d'utilisateur fourni lors de l'authentification
                    client_handler = ClientHandler(client_socket, addr, self, username)
                    client_handler.set_current_channel(1)  # Spécifie le canal initial ici
                    client_handler.disconnected.connect(self.handle_client_disconnected)
                    client_handler.start()

                    self.clients.append((client_handler, addr))

                else:
                    print(f"Identification échouée. Connexion refusée pour {addr[0]}:{addr[1]}")
                    self.window.text_edit.append(f"Identification échouée. Connexion refusée pour {addr[0]}:{addr[1]}")

        except Exception as e:
            print(f"Erreur de connexion : {e}")

    def authenticate(self, client_socket):
        try:
            data = client_socket.recv(1024)
            if not data:
                return False

            credentials = data.decode('utf-8').split(':')
            action = credentials[0]

            if action == "création_utilisateur":
                return self.handle_user_creation(client_socket, credentials)
            elif action == "connexion":
                return self.handle_user_authentication(credentials)
            else:
                print(f"Action non reconnue : {action}")
                return False

        except Exception as e:
            print(f"Erreur lors de l'authentification : {e}")
            return False

    def handle_user_creation(self, client_socket, credentials):
        try:
            # Création d'un nouvel utilisateur
            username, pseudo, password = credentials[1], credentials[2], credentials[3]

            # Insérer le nouvel utilisateur dans la base de données
            if self.insert_new_user(username, pseudo, password):
                # Informer que le nouvel utilisateur a été créé
                self.new_user_created.emit(f"Nouvel utilisateur créé: {username}")
                return True
            else:
                print(f"Erreur lors de la création du nouvel utilisateur : {username}")
                return False

        except Exception as e:
            print(f"Erreur lors de la gestion de la création d'utilisateur : {e}")
            return False

    def handle_user_authentication(self, credentials):
        try:
            # Vérification des identifiants pour la connexion
            username, password = credentials[1], credentials[2]

            cursor = self.db_connection.cursor()
            cursor.execute("SELECT * FROM users WHERE username = %s AND password = %s AND ban = 0",
                           (username, password))
            result = cursor.fetchone()
            cursor.close()

            if result:
                print(f"Identifiants valides pour {username}")
            else:
                print(f"Identifiants invalides pour {username}")

            return result is not None

        except Exception as e:
            print(f"Erreur lors de la vérification des identifiants : {e}")
            return False

    def stop_server(self):
        self.window.set_status("Le serveur est arrêté.")
        self.window.text_edit.append("Le serveur a été arrêté.")
        self.server_socket.close()

        for client_handler, _ in self.clients:
            client_handler.client_socket.close()

        self.wait()

    def verify_credentials(self, client_socket):
        try:
            data = client_socket.recv(1024)
            if not data:
                return False

            credentials = data.decode('utf-8').split(':')
            if credentials[0] == "création_utilisateur":
                # Création d'un nouvel utilisateur
                username, pseudo, password = credentials[1], credentials[2], credentials[3]

                # Insérer le nouvel utilisateur dans la base de données
                if self.insert_new_user(username, pseudo, password):
                    # Informer que le nouvel utilisateur a été créé
                    self.new_user_created.emit(f"Nouvel utilisateur créé: {username}")
                    return True
                else:
                    print(f"Erreur lors de la création du nouvel utilisateur : {username}")
                    return False
            else:
                # Vérification des identifiants pour la connexion
                username, password = credentials[0], credentials[1]

                cursor = self.db_connection.cursor()
                cursor.execute("SELECT * FROM users WHERE username = %s AND password = %s AND ban = 0",
                               (username, password))
                result = cursor.fetchone()
                cursor.close()

                if result:
                    print(f"Identifiants valides pour {username}")
                else:
                    print(f"Identifiants invalides ou utilisateur banni pour {username}")

                return result is not None

        except Exception as e:
            print(f"Erreur lors de la vérification des identifiants : {e}")
            return False

    def insert_new_user(self, username, pseudo, password):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("INSERT INTO users (username, pseudo, password) VALUES (%s, %s, %s)",
                           (username, pseudo, password))
            self.db_connection.commit()
            cursor.close()
            return True
        except Exception as e:
            print(f"Erreur lors de l'insertion du nouvel utilisateur dans la base de données : {e}")
            return False

    def handle_client_message(self, message, username, client_handler):
        sender_username, content = message.split(':', 1)
        sender_username = sender_username.strip()

        # Enregistrement du message uniquement si ce n'est pas un changement de canal
        if not message.lower().startswith("changement de canal"):
            current_channel_id = client_handler.current_channel
            if current_channel_id is not None:
                content = content.strip()
                self.message_received.emit(f"{sender_username}: {content}")
                self.insert_message(sender_username, current_channel_id, content)
                self.broadcast_message(f"{sender_username}: {content}", client_handler.addr)
        else:
            # Si c'est un "Changement de canal", mettez à jour le canal actuel du client
            parts = message.split(":")
            if len(parts) >= 2:
                channel_name = parts[1].strip()
                channel_id = self.CHANNEL_IDS.get(channel_name)
                if channel_id is not None:
                    client_handler.set_current_channel(channel_id)
                    self.message_received.emit(f"{sender_username}: {message}")
                    self.insert_message(sender_username, None, message)
                    self.broadcast_message(f"{sender_username}: {message}", client_handler.addr)
                else:
                    self.message_received.emit(f"Canal non trouvé : {channel_name}")
            else:
                self.message_received.emit(f"Commande de changement de canal mal formée : {message}")

    def insert_message(self, username, channel_id, content):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("INSERT INTO messages (username, channel_id, content) VALUES (%s, %s, %s)",
                           (username, channel_id, content))
            self.db_connection.commit()
            cursor.close()
        except Exception as e:
            print(f"Erreur lors de l'insertion du message dans la base de données : {e}")

    def broadcast_message(self, message, sender_addr):
        # Exclure les messages "Changement de canal"
        if "Changement de canal" not in message:
            for client_handler, addr in self.clients:
                if addr != sender_addr:
                    try:
                        client_handler.client_socket.sendall(message.encode('utf-8'))
                    except Exception as e:
                        print(f"Erreur lors de l'envoi du message au client {addr}: {e}")

    def handle_client_disconnected(self, addr):
        for client_handler, client_addr in self.clients:
            if client_addr == addr:
                self.clients.remove((client_handler, client_addr))
                self.message_received.emit(f"Client déconnecté : {addr[0]}:{addr[1]}")
                self.window.text_edit.append(f"Client déconnecté : {addr[0]}:{addr[1]}")

    def kick_user(self, username, kick_expire):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET kick_expire = %s, ban = 1 WHERE username = %s", (kick_expire, username))
            self.db_connection.commit()
            cursor.close()
            self.broadcast_message(f"{username} a été kické jusqu'au {kick_expire}.", None)
        except Exception as e:
            print(f"Erreur lors du Kick de l'utilisateur {username} : {e}")

    def ban_user(self, username, ban_expire):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET ban_expire = %s, ban = 1 WHERE username = %s", (ban_expire, username))
            self.db_connection.commit()
            cursor.close()
            self.broadcast_message(f"{username} a été banni jusqu'au {ban_expire}.", None)
        except Exception as e:
            print(f"Erreur lors du Ban de l'utilisateur {username} : {e}")

    def unban_user(self, username):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET ban_expire = NULL, ban = 0 WHERE username = %s", (username,))
            self.db_connection.commit()
            cursor.close()
            self.broadcast_message(f"{username} n'est plus banni.", None)
        except Exception as e:
            print(f"Erreur lors de la suppression du Ban de l'utilisateur {username} : {e}")

    def unkick_user(self, username):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET kick_expire = NULL, ban = 0 WHERE username = %s", (username,))
            self.db_connection.commit()
            cursor.close()
            self.broadcast_message(f"{username} n'est plus kické.", None)
        except Exception as e:
            print(f"Erreur lors de la suppression du Kick de l'utilisateur {username} : {e}")

    def check_user_timeouts(self):
        try:
            cursor = self.db_connection.cursor(dictionary=True)
            cursor.execute("SELECT username, kick_expire, ban_expire FROM users WHERE kick_expire IS NOT NULL OR ban_expire IS NOT NULL")
            users = cursor.fetchall()
            cursor.close()

            current_datetime = datetime.datetime.now()

            for user in users:
                username = user["username"]
                kick_expire = user["kick_expire"]
                ban_expire = user["ban_expire"]

                if kick_expire is not None and kick_expire < current_datetime:
                    # Réinitialiser la colonne kick_expire à zéro
                    self.reset_kick_expire(username)

                if ban_expire is not None and ban_expire < current_datetime:
                    # Réinitialiser les colonnes ban_expire à zéro
                    self.reset_ban_expire(username)

        except Exception as e:
            print(f"Erreur lors de la vérification des délais d'expiration : {e}")

    def reset_kick_expire(self, username):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET kick_expire = NULL, ban = 0 WHERE username = %s", (username,))
            self.db_connection.commit()
            cursor.close()
        except Exception as e:
            print(f"Erreur lors de la suppression du Kick de l'utilisateur {username} : {e}")

    def reset_ban_expire(self, username):
        try:
            cursor = self.db_connection.cursor()
            cursor.execute("UPDATE users SET ban_expire = NULL, ban = 0 WHERE username = %s", (username,))
            self.db_connection.commit()
            cursor.close()
        except Exception as e:
            print(f"Erreur lors de la suppression du Ban de l'utilisateur {username} : {e}")


class ServerWindow(QMainWindow):
    stop_server_signal = pyqtSignal()

    def __init__(self, server):
        super().__init__()

        self.server = server

        self.setWindowTitle("Serveur")
        self.setGeometry(100, 100, 600, 400)

        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)

        self.layout = QVBoxLayout()

        self.text_edit = QTextEdit(self)
        self.layout.addWidget(self.text_edit)

        self.input_line = QLineEdit(self)
        self.layout.addWidget(self.input_line)

        self.send_button = QPushButton("Envoyer", self)
        self.send_button.clicked.connect(self.send_message)
        self.layout.addWidget(self.send_button)

        self.stop_button = QPushButton("Arrêter le serveur", self)
        self.stop_button.clicked.connect(self.stop_server)
        self.layout.addWidget(self.stop_button)

        self.central_widget.setLayout(self.layout)

        self.setup_ui()

        self.server.message_received.connect(self.handle_message_received)
        self.server.client_connected.connect(self.handle_client_connected)
        self.server.new_user_created.connect(self.handle_new_user_created)

        self.kick_button = QPushButton("Kick", self)
        self.kick_button.clicked.connect(self.kick_user)
        self.layout.addWidget(self.kick_button)

        self.ban_button = QPushButton("Ban", self)
        self.ban_button.clicked.connect(self.ban_user)
        self.layout.addWidget(self.ban_button)

        self.unban_button = QPushButton("Supprimer le Ban", self)
        self.unban_button.clicked.connect(self.unban_user)
        self.layout.addWidget(self.unban_button)

        self.unkick_button = QPushButton("Enlever le Kick", self)
        self.unkick_button.clicked.connect(self.unkick_user)
        self.layout.addWidget(self.unkick_button)

        self.kick_button = QPushButton("Pour Kick", self)
        self.layout.addWidget(self.kick_button)

        self.kick_datetime_edit = QDateTimeEdit(self)
        self.layout.addWidget(self.kick_datetime_edit)

        self.ban_button = QPushButton("Pour Ban", self)
        self.layout.addWidget(self.ban_button)

        self.ban_datetime_edit = QDateTimeEdit(self)
        self.layout.addWidget(self.ban_datetime_edit)


        self.server.start()

    def stop_server(self):
        self.stop_server_signal.emit()

    def send_message(self):
        self.server.broadcast_message(f"Server: {self.input_line.text()}", None)
        self.input_line.clear()

    def handle_message_received(self, message):
        self.text_edit.append(message)

    def handle_client_connected(self, addr):
        self.text_edit.append(f"Client connecté : {addr[0]}:{addr[1]}")

    def handle_new_user_created(self, message):
        print("Handling new user creation:", message)
        self.text_edit.append(message)
        # Ajoutez ici le code pour traiter la création d'un nouvel utilisateur, si nécessaire

    def kick_user(self):
        username = self.get_selected_username()
        if username:
            # Utilisez la valeur sélectionnée dans le QDateTimeEdit
            kick_expire = self.kick_datetime_edit.dateTime().toPyDateTime()
            self.server.kick_user(username, kick_expire)

    def ban_user(self):
        username = self.get_selected_username()
        if username:
            ban_expire = self.ban_datetime_edit.dateTime().toPyDateTime()
            self.server.ban_user(username, ban_expire)

    def unban_user(self):
        username = self.get_selected_username()
        if username:
            self.server.unban_user(username)

    def unkick_user(self):
        username = self.get_selected_username()
        if username:
            self.server.unkick_user(username)

    def get_selected_username(self):
        index = self.user_combo.currentIndex()
        if index > 0:
            return self.user_combo.currentText()
        return None

    def setup_ui(self):

        # Créer un menu déroulant pour les utilisateurs
        self.user_combo = QComboBox(self)
        self.layout.addWidget(self.user_combo)

        # Charger les utilisateurs depuis la base de données
        self.load_users()

    def load_users(self):
        try:
            cursor = self.server.db_connection.cursor(dictionary=True)
            cursor.execute("SELECT username FROM users")
            users = cursor.fetchall()
            cursor.close()

            # Ajouter les utilisateurs au menu déroulant
            self.user_combo.addItem("Sélectionner un utilisateur")
            for user in users:
                self.user_combo.addItem(user["username"])

        except Exception as e:
            print(f"Erreur lors du chargement des utilisateurs : {e}")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    server = Server()
    sys.exit(app.exec_())
